import qtrio._pytest


<<<<<<< HEAD
def test_wait_signal_returns_the_value(testdir):
=======
def test_overrunning_test_times_out(testdir):
>>>>>>> master
    """The overrunning test is timed out."""

    test_file = rf"""
    import qtrio
    import trio

    @qtrio.host
    async def test(request):
        await trio.sleep({2 * qtrio._pytest.timeout})
    """
    testdir.makepyfile(test_file)

    timeout = qtrio._pytest.timeout

<<<<<<< HEAD
    result = testdir.runpytest_subprocess(timeout=10)
=======
    result = testdir.runpytest_subprocess(timeout=2 * qtrio._pytest.timeout)
>>>>>>> master
    result.assert_outcomes(failed=1)
    result.stdout.re_match_lines(
        lines2=[f"E       AssertionError: test not finished within {timeout} seconds"],
    )


# TODO: test that the timeout case doesn't leave trio active...  like
#       it was doing five minutes ago.


def test_hosted_assertion_failure_fails(testdir):
    """QTrio hosted test which fails an assertion fails the test."""

    test_file = r"""
    import qtrio

    @qtrio.host
    async def test(request):
        assert False
    """
    testdir.makepyfile(test_file)

    result = testdir.runpytest_subprocess(timeout=10)
    result.assert_outcomes(failed=1)
